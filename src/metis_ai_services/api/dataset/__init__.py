# 1. Create request parsers/API models to validate request data and serialize response data.
# 2. Define the business logic necessary to process the request if validation succeeds.
# 3. Create a class that inherits from Resource and bind it to the API endpoint/URL route.
# 4. Define the set of HTTP methods that the API endpoint will support and expose methods on
#    the concrete Resource class for each. Methods named get, post, put, delete, patch, options or
#    head will be called when the API endpoint receives a request of the same HTTP method type.
# // If the API endpoint does not support the HTTP method, do not expose a method with the name of
#    the HTTP method and the client will receive a response with status code 405
#    HTTPStatus.METHOD_NOT_ALLOWED.
# 5. Document the Resource class and all methods as explained in the Flask-RESTx docs. Most of the
#    content on the Swagger UI page is generated by decorating your concrete Resource classes
#    and their methods.
# 6. Utilize the business logic created in Step 2 within the approprate HTTP methods to process
#    the request.
# 7. Create unit tests to verify that the input validation provided by the request parsers/API
#    models is working correctly, and verify the endpoint behaves as expected.
